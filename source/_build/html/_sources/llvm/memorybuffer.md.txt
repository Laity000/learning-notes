

# LLVM如何将文件读入内存 --`llvm::MemoryBuffer`

> 本文是对[How Swift and Clang Use LLVM to Read Files into Memory](https://modocache.io/llvm-memory-buffer)的学习，加上自己的笔记，更新为llvm17.0.0的源码。英语不错的小伙伴可以直接阅读原文。

`llvm::MemoryBuffer`是将文件或流读入内存的主要抽象类。由于它经常被 Swift、Clang 和 LLVM 等工具（如 llvm-tblgen）使用，了解它的工作原理非常有价值。

比如，`llvm::MemoryBuffer`会传递给`llvm::SourceMgr`，以便在缓冲区的特定位置发出诊断信息。

## 一、C++将文件读入内存

作者首先在第一章介绍了c++读取文件的两种方式：

https://llvm.org/doxygen/classllvm_1_1MemoryBuffer.html

libLLVMSupport的llvm::MemoryBuffer类的文档表示它“提供对内存块的简单只读访问，并提供将文件和标准输入读入内存缓冲区的简单方法。”为了更好地理解它是如何做到的，我尝试编写了一个简单的C++程序，名为read.cpp，它将一个文件 - 在这种情况下是它自己 - 读入内存中。为了简单起见，我的程序仅适用于Unix系统。

### 传统读取文件到内存的方式

读取文件的调用四个系统函数：

1. [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html)：用于获取文件的文件描述符。
2. [`fstat`](http://man7.org/linux/man-pages/man2/stat.2.html)：返回与文件描述符相关的信息。比如文件的size。
3. [`read(2)`](http://man7.org/linux/man-pages/man2/read.2.html)：从文件中读取指定数量的字节到预先分配的内存块中。
4. [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html)：用于在使用完文件描述符后关闭文件。

作者写了一个`read.cpp` 程序的例子：分配内存并将其自身的源文件读入该内存中，并打印出文件的第一行。实际上，这与`llvm::MemoryBuffer::getFile`函数非常相似。但是还有改进的空间。

### 使用 mmap(2) 将大文件读入内存

回想一下，我们使用`new`运算符在堆上分配了内存，然后使用系统调用 read(2) 来将文件的内容填充到该内存中：如果我们需要读取一个非常大的文件到内存中，这种分配方式就会有问题。一个大小为1GB的文件会导致分配1GB的内存空间，这是相当大的RAM！

作者在`read.cpp` 程序中加上了`mmap(2)`的使用。

这篇博客详细介绍了`mmap`的原理：[认真分析mmap：是什么 为什么 怎么用 ](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

- `mmap(2)` 允许我们一次读取文件的部分位。**常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。**

- 当读写磁盘文件的数据较小(少于1MB)时候，使用内存文件映射和普通IO是差异很小的，所以建议使用普通IO就可以了；**当很多文件的大小在几十MB, 几百MB, 或者1GB以上的文件数据需要进行较频繁的访问，或者一开始需要全部加载这些大文件的时候，那么就需要考虑使用内存文件映射了。**

回到文章

大多数情况下，`llvm::MemoryBuffer` 的工作方式与上面的` read.cpp` 程序完全相同。它还有一些额外的功能：可以在 Unix 和 Windows 上运行，使用更复杂的启发式来决定是否使用 `mmap(2)`，并且在支持它们的平台上使用一些有趣的系统调用和选项。会在下面详细介绍这些内容。

## 二、LLVM读文件的实现：llvm::MemoryBuffer::getFileOrSTDIN

`llvm::MemoryBuffer::getFileOrSTDIN`函数返回给定文件的 `llvm::MemoryBuffer``std::unique_ptr`，或者返回y一个`llvm::ErrorOr`类型表示。（关于`llvm::ErrorOr`的内容，可以观看 [LLVM Developers Meeting 2016 ](https://www.youtube.com/watch?v=Wq8fNK98WGw)了解更多信息。）

[llvm/include/llvm/Support/MemoryBuffer.h](https://github.com/Laity000/llvm-project/blob/llvmorg-17.0.0/llvm/include/llvm/Support/MemoryBuffer.h#L147-L152)
```c++
  /// Open the specified file as a MemoryBuffer, or open stdin if the Filename
  /// is "-".
  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFileOrSTDIN(const Twine &Filename, bool IsText = false,
                 bool RequiresNullTerminator = true,
                 std::optional<Align> Alignment = std::nullopt);
```
[llvm/lib/Support/MemoryBuffer.cpp](https://github.com/Laity000/llvm-project/blob/llvmorg-17.0.0/llvm/lib/Support/MemoryBuffer.cpp#L155-L166)
```c++
ErrorOr<std::unique_ptr<MemoryBuffer>>
MemoryBuffer::getFileOrSTDIN(const Twine &Filename, bool IsText,
                             bool RequiresNullTerminator,
                             std::optional<Align> Alignment) {
  SmallString<256> NameBuf;
  StringRef NameRef = Filename.toStringRef(NameBuf);

  if (NameRef == "-")
    return getSTDIN();
  return getFile(Filename, IsText, RequiresNullTerminator,
                 /*IsVolatile=*/false, Alignment);
}
```

`getFileOrSTDIN`函数只是检查文件名是否为“-”，然后将其逻辑交给`llvm::MemoryBuffer::getSTDIN`或`getFile`。

https://github.com/Laity000/llvm-project/blob/llvmorg-17.0.0/llvm/lib/Support/MemoryBuffer.cpp#L252-L281
```c++
ErrorOr<std::unique_ptr<MemoryBuffer>>
MemoryBuffer::getFile(const Twine &Filename, bool IsText,
                      bool RequiresNullTerminator, bool IsVolatile,
                      std::optional<Align> Alignment) {
  return getFileAux<MemoryBuffer>(Filename, /*MapSize=*/-1, /*Offset=*/0,
                                  IsText, RequiresNullTerminator, IsVolatile,
                                  Alignment);
}

template <typename MB>
static ErrorOr<std::unique_ptr<MB>>
getFileAux(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
           bool IsText, bool RequiresNullTerminator, bool IsVolatile,
           std::optional<Align> Alignment) {
  Expected<sys::fs::file_t> FDOrErr = sys::fs::openNativeFileForRead(
      Filename, IsText ? sys::fs::OF_TextWithCRLF : sys::fs::OF_None);
  if (!FDOrErr)
    return errorToErrorCode(FDOrErr.takeError());
  sys::fs::file_t FD = *FDOrErr;
  auto Ret = getOpenFileImpl<MB>(FD, Filename, /*FileSize=*/-1, MapSize, Offset,
                                 RequiresNullTerminator, IsVolatile, Alignment);
  sys::fs::closeFile(FD);
  return Ret;
}
```

这里我们重点看下`getFile`函数，委托给一个名为`getFileAux`局部静态函数。实现了上面的 `read.cpp` 示例中的一些逻辑：打开文件以获取文件描述符，读取该文件，然后调用`close(2)`以关闭文件描述符。·

## LLVM文件系统

但是`getFileAux`函数不会直接调用`open(2)`系统调用来获取给定文件名的打开文件描述符。相反，它使用`llvm::sys::fs::openNativeFileForRead`函数。这个LLVM辅助函数与`open(2)`不同，可以在Windows和Unix平台上工作。

下面这里FileSystem.h头文件，和`llvm::sys::fs::openNativeFileForRead`函数声明，根据平台的类型不同分别在`llvm/lib/Support/Unix/Path.inc`和`llvm/lib/Support/Windows/Path.inc`中各自实现

[llvm/include/llvm/Support/FileSystem.h](https://github.com/Laity000/llvm-project/blob/llvmorg-17.0.0/llvm/include/llvm/Support/FileSystem.h#L1133-L1165)


```c++
// This file declares the llvm::sys::fs namespace. It is designed after
// TR2/boost filesystem (v3), but modified to remove exception handling and the
// path class.
#if defined(_WIN32)
// A Win32 HANDLE is a typedef of void*
using file_t = void *;
#else
using file_t = int;
#endif

... 

/// @brief Opens the file with the given name in a read-only mode, returning
/// its open file descriptor.
/// @returns a platform-specific file descriptor if \a Name has been opened,
///          otherwise an error object.
Expected<file_t>
openNativeFileForRead(const Twine &Name, OpenFlags Flags = OF_None,
                      SmallVectorImpl<char> *RealPath = nullptr);

/// @brief Opens the file with the given name in a read-only mode, returning
/// its open file descriptor.
/// @param Name The path of the file to open, relative or absolute.
/// @param ResultFD If the file could be opened successfully, its descriptor

std::error_code openFileForRead(const Twine &Name, int &ResultFD,
                                OpenFlags Flags = OF_None,
                                SmallVectorImpl<char> *RealPath = nullptr);

```
比如llvm/lib/Support/Unix/Path.inc，这里走的就是Unix平台的。最终会产生一个文件描述符`file_t ResultFD`
```c++
Expected<file_t> openNativeFileForRead(const Twine &Name, OpenFlags Flags,
                                       SmallVectorImpl<char> *RealPath) {
  file_t ResultFD;
  std::error_code EC = openFileForRead(Name, ResultFD, Flags, RealPath);
  if (EC)
    return errorCodeToError(EC);
  return ResultFD;
}
```

### LLVM 中的系统调用的跨平台实现

## Reading the file into an `llvm::WritableMemoryBuffer`

llvm::sys::fs::openFileForRead函数打开一个文件并返回其文件描述符。然后控制返回到getFileAux函数，该函数将打开的描述符传递给getOpenFileImpl静态函数。



getOpenFileImpl实现了本文开头的read.cpp示例中的相同逻辑。如果未提供文件大小，则通过调用llvm::sys::fs::status来找出文件的大小，该函数在Unix系统中调用fstat。然后，它会根据情况决定是使用mmap(2)还是使用operator new提前分配内存。如果它分配了内存，那么它将使用系统调用read(2)（如果HAVE_PREAD为true，则使用pread）来将文件的字节读入内存中。



llvm::sys::Process::getPageSize和llvm::sys::fs::status函数上面使用了与llvm::sys::fs::openFileForRead相同的CMake技巧，以包含平台特定的实现：getPageSize在llvm/lib/Support/Unix/Process.inc和Windows/Process.inc中实现，而status在Unix/Path.inc和Windows/Path.inc中实现。在Unix上，它们使用系统调用getpagesize和fstat来从操作系统获取所需的信息。



上面的代码根据辅助函数 shouldUseMMap 返回 true 还是 false，实例化了 llvm::MemoryBufferMMapFile 或 llvm::WritableMemoryBuffer。就像在本文开头的 read.cpp 示例中一样，决定使用哪种方式的一个标准是文件的大小 - 例如，如果文件大小小于系统上的一页，或小于16千字节，则不使用 mmap(2)：



1. 1.通过火焰图和dump时间初步发现性能瓶颈是在对ld文件的anltr parser。
2. 2.分析了下发现是ld中有对label_stmt语句的parser性能很差，比如最差的，删除label之后213291ms-->414ms，恢复到正常水平
3. 3.后面需要具体分析下原因看怎么改